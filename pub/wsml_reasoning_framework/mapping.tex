% -- tau-transformations
\newcommand{\smtxtit}[1]{\begin{scriptsize}\ensuremath{\textit{#1}}\end{scriptsize}}
\newcommand{\trans}[1]{\ensuremath{\tau_{#1}}\xspace}
\newcommand{\transtxt}[1]{\trans{\smtxtit{#1}}}
\def\transax{\transtxt{axioms}}
\def\transnorm{\transtxt{norm}}
\def\translt{\transtxt{lt}}
\def\transdlog{\transtxt{datalog}}

\def\LE{\ensuremath{\mathcal{L\!E}}\xspace}
\def\O{\ensuremath{\mathcal{O}}\xspace}
\def\P{\ensuremath{\mathcal{P}}\xspace}
\newcommand{\powset}[1]{\ensuremath{2^{#1}}\xspace}
\def\lprl{\ensuremath{\;:\!-\:}}
\def\cstr{\ensuremath{\;!-\:}}
\def\qury{\ensuremath{\;?-\:}}
\def\dlogrule{\lprl}
\def\dlogcstr{\square\lprl}
\def\dlogand{\wedge}
\def\dlognot{\sim}
\newcommand{\dlogfact}[1]{\ensuremath{{#1}\;.}}

% -- meta-level predicates
\newcommand{\predicate}[1]{\ensuremath{p_{#1}}\xspace}
\newcommand{\predsubtxt}[1]{\mathrm{\sf #1}}
\def\psco{\predicate{\predsubtxt{sco}}}
\def\pmo{\predicate{\predsubtxt{mo}}}
\def\phval{\predicate{\predsubtxt{hval}}}
\def\pitype{\predicate{\predsubtxt{itype}}}
\def\potype{\predicate{\predsubtxt{otype}}}
\def\mlaxioms{\ensuremath{P_{\smtxtit{meta}}}\xspace}

\newcommand{\typeof}{\ensuremath{typeOf}\xspace}

\section{Realizing WSML Reasoning through a Mapping to Datalog\label{sec:mapping}}
-- briefly sketch the idea of reasoning via rule based inferencing \\

The semantics of rule-based WSML is defined via a mapping to
datalog with (in)equality and integrity constraints. \sgr{probably
use a special denotation like $\textit{datalog}^{!=,IC}$, which
then has to be introduced in Section 2} To make use of existing
rule engines, the reasoning framework performs various
transformations to convert an original ontology in WSML syntax
into datalog rules. To maintain the semantics of more complex WSML
language constructs that cannot directly be expressed in datalog,
a fixed set of rules form the meta-level axioms that realise part
of the WSML semantics during reasoning. Based on the transformed
ontology, the WSML reasoning tasks of knowledge base
satisfiability and instance retrieval are realised by datalog
querying via calls to an underlying datalog inference engine that
is fed with the rules produced during transformation together with
the meta-level axioms.

\subsection{Transforming WSML to Datalog}
-- describe different transformation steps \\

The transformation of a WSML ontology to datalog rules forms a
pipeline of single transformation steps which are subsequently
applied, starting from the original ontology.

\paragraph{Axiomatization} -- In a first step, the transformation
\transax is applied as a mapping $\O \mapsto \powset{\LE}$ from
the set of all valid rule-based WSML ontologies to the powerset of
all logical expressions that conform to rule-based WSML. \transax
converts all conceptual syntax elements, such as concept and
attribute definitions or cardinality and type constraints, into
appropriate logical expressions according to
\cite{wsml-spec}(Table 8.1). \sgr{give the complete conversion
table instead of the following example ??}

To give an example, the WSML fragment
\begin{lstlisting}[style=wsml]
concept C subConceptOf D
    r ofType (0 2) T
instance a memberOf C
    r hasValue b,c
\end{lstlisting}
is translated by \transax to the following logical expressions.
\begin{lstlisting}[style=wsml]
C subConceptOf D. C[r ofType T].
!- ?x memberOf C and ?x[r hasValue?y1, r hasValue ?y2] and ?y1 != ?y2.
a memberOf C.  a hasValue b,c.
\end{lstlisting}

\paragraph{Normalization} -- The transformation \transnorm is
applied to normalize WSML logical expressions as a mapping
$\powset{\LE} \mapsto \powset{\LE}$. This normalization step
reduces the complexity of WSML logical expressions according to
\cite{wsml-spec}(Section 8.2) to make them better fit the simple
syntactic form of literals in datalog rules. This reduction
includes conversion to negation and disjunctive normal forms as
well as decomposition of complex WSML molecules. The various
normalization steps are shown in Table \ref{tab:normalization}.
\sgr{include this table or rather skip it??} After \transnorm has
been applied, the resulting WSML logical expressions have the form
of logic programming rules with no deep nesting of logical
connectives.

\begin{table}[tb]\label{tab:normalization}\centering
\begin{footnotesize}
\begin{tabular}{|l|l|}
  \hline
  \rule{0cm}{3.2mm}{\normalsize \emph{original expression}} & {\normalsize \emph{normalized expression}} \\
  \hline
    $\transnorm(\{E_1 , \dots , E_n\})$ & $\{\transnorm(E_1) , \dots , \transnorm(E_n)\}$ \\
    $\transnorm(X$ \wsml{and} $Y.)$ & $\transnorm(X)$ \wsml{and} $\transnorm(Y)$ \\
    $\transnorm(X$ \wsml{or} $Y.)$ & $\transnorm(X)$ \wsml{or} $\transnorm(Y)$ \\
    $\transnorm(X$ \wsml{and} $(Y$ \wsml{or} $Z).)$ & $\transnorm(\transnorm(X)$ \wsml{and} $\transnorm(Y)$ \wsml{or} \\
    & $\phantom{\transnorm(}\transnorm(X)$ \wsml{and} $\transnorm(Z).)$ \\
    $\transnorm((X$ \wsml{or} $Y)$ \wsml{and} $Z).)$ & $\transnorm(\transnorm(X)$ \wsml{and} $\transnorm(Z)$ \wsml{or} \\
    & $\phantom{\transnorm(}\transnorm(Y)$ \wsml{and} $\transnorm(Z).)$ \\
    $\transnorm($ \wsml{naf} $ (X$ \wsml{and} $Y).)$ & $$ \wsml{naf} $ \transnorm(X)$ \wsml{or} $$ \wsml{naf} $ \transnorm(Y).$ \\
    $\transnorm($ \wsml{naf} $ (X$ \wsml{or} $Y).)$ & $$ \wsml{naf} $ \transnorm(X)$ \wsml{and} $$ \wsml{naf} $ \transnorm(Y).$ \\
    $\transnorm($ \wsml{naf} $ ($ \wsml{naf} $ X).)$ & $\transnorm(X)$ \\
    $\transnorm(X$ \wsml{implies} $Y.)$ & $\transnorm(Y)$\wsml{\lprl}$\transnorm(X).$ \\
    $\transnorm(X$ \wsml{impliedBy} $Y.)$ & $\transnorm(X)$\wsml{\lprl}$\transnorm(Y).$ \\
    $\transnorm(X[Y_1 , \dots , Y_n].)$ & $X[Y_1]$ \wsml{and} $\dots$ \wsml{and} $X[Y_n].$ \\
  \hline
\end{tabular}
\end{footnotesize}
\caption{Normalization of WSML logical expressions.}
\end{table}

\paragraph{Lloyd-Topor Transformation} -- The transformation
\translt is applied as a mapping $\powset{\LE} \mapsto
\powset{\LE}$ to flatten the complex WSML logical expressions,
producing simple rules according to the Lloyd-Topor
transformations \cite{lloyd-topor}, as shown in Table
\ref{tab:lloyd-topor}. \sgr{is the specification of the
lloyd-topor transformations correct? (esp. the middle one with
nested LP-rule and the lack of parenthesis)}
\begin{table}[tb]\label{tab:lloyd-topor}\centering
\begin{footnotesize}
\begin{tabular}{|l|l|}
  \hline
  \rule{0cm}{3.2mm}{\normalsize \emph{original expression}} & {\normalsize \emph{simplified rule(s)}} \\
  \hline
  $\translt(H_1$ \wsml{and} $\dots$ \wsml{and} $H_n$\wsml{\lprl}$B.)$ & $\translt(H_1$\wsml{\lprl}$B.)$ , \dots , $\translt(H_n$\wsml{\lprl}$B.)$ \\
  $\translt(H_1$\wsml{\lprl}$H_2$\wsml{\lprl}$B.)$ & $\translt(H_1$\wsml{\lprl}$H_2$ \wsml{and} $B.)$ \\
  $\translt(H$\wsml{\lprl} $B_1$ \wsml{or} , $\dots$ , \wsml{or} $B_n.)$ & $\translt(H$\wsml{\lprl}$B_1.)$ , \dots , $\translt(H$\wsml{\lprl}$B_n.)$ \\
  \hline
\end{tabular}
% --old tabel with Lloyd-Topor trasnformations
%\begin{tabular}{|c|c|}
%  \hline
%  % after \\: \hline or \cline{col1-col2} \cline{col3-col4} ...
%  \emph{original expression} & \emph{simplified rule(s)} \\
%  \hline
%  $H_1 \wedge \dots \wedge H_n \leftarrow B$ & $H_1 \leftarrow B , \dots , H_n \leftarrow B$ \\
%  $H_1 \leftarrow H_2 \leftarrow B$ & $H_1 \leftarrow H_2 \wedge B$ \\
%  $H \leftarrow B_1 \vee \dots \vee B_n$ & $H \leftarrow B_1 , \dots , H \leftarrow B_n$ \\
%  \hline
%\end{tabular}
\end{footnotesize}
\caption{Lloyd-Topor transformations.}
\end{table}
After this step, the resulting WSML expressions have the form of
proper datalog rules with a single head and conjunctive (possibly
negated) body literals.

\paragraph{Datalog Rule Generation} -- In a final step, the
transformation \transdlog is applied as a mapping $\powset{\LE}
\mapsto \P$ from all valid logical expressions in rule-based WSML
to the set of all datalog programs, yielding generic datalog rules
that represent the content of the original WSML ontology. In this
generic datalog program, all remaining WSML-specific language
constructs, such as \wsml{subConceptOf} or \wsml{ofType}, are
replaced by special meta-level predicates for which the semantics
of the respective language construct is encoded in meta-level
axioms as described in a further subsection.
\begin{table}[tb]\label{tab:LE2datalog}\centering
\begin{footnotesize}
\begin{tabular}{|l|l|}
  \hline
  \rule{0cm}{3.2mm} {\normalsize \emph{WSML}} & {\normalsize \emph{Datalog}} \\
  \hline
  $\transdlog(\{E_1, \dots , E_n\})$ & $\{\transdlog(E_1), \dots , \transdlog(E_n)\}$ \\
  $\transdlog($ \wsml{\cstr} $B.)$ & $\dlogcstr \transdlog(B)$ \\
  $\transdlog(H)$ & \dlogfact{\transdlog(H)} \\
  $\transdlog(H$ \wsml{\lprl} $B.)$ & $\transdlog(H) \dlogrule \transdlog(B)$ \\
  $\transdlog(X$ \wsml{and} $Y.)$ & $\transdlog(X) \dlogand \transdlog(Y)$ \\
  $\transdlog(C$ \wsml{subConceptOf} $D.)$ & $\psco(C,D)$ \\
  $\transdlog(I$ \wsml{memberOf} $C.)$ & $\pmo(I,C)$ \\
  $\transdlog(I[a$ \wsml{hasValue} $V].)$ & $\phval(I,a,V)$ \\
  $\transdlog(C[a$ \wsml{impliesType} $T].)$ & $\pitype(C,a,T)$ \\
  $\transdlog(C[a$ \wsml{ofType} $T].)$ & $\potype(C,a,T)$ \\
  $\transdlog($\wsml{r}$(X_1, \dots , X_n).)$ & $r(X_1, \dots , X_n)$ \\
  $\transdlog(X$ \wsml{=} $Y.)$ & $X = Y$ \\
  $\transdlog(X$ \wsml{!=} $Y.)$ & $X \neq Y$ \\
  \hline
\end{tabular}
\end{footnotesize}
\caption{Transformation from logical expressions in rule-based
WSML to datalog including meta-level predicates.}
\end{table}
Table \ref{tab:LE2datalog} shows the mapping from WSML logical
expressions to datalog including the meta-level predicates \psco,
\pmo, \phval, \pitype and \potype that represent their respective
WSML language constructs as can be seen from the mapping. {\bf HL
would not mention != and = just normal built-ins...} 

\bigskip

Ultimately, the basic\footnote{In Section \ref{sec:debugging} the
transformation pipeline is modified to support debugging
features.} transformation pipeline for converting a rule-based
WSML ontology into a datalog program is the following, constituted
by the single transformation steps introduced before.
\begin{displaymath}
    \tau = \transdlog \circ \translt \circ \transnorm \circ \transax
\end{displaymath}
As a mapping $\O \mapsto \P$, this chaining of the single steps is
applied to a WSML ontology $O \in \O$ to yield a semantically
equivalent datalog program $\tau (O) = P \in \P$ when interpreted
with respect to the meta-level axioms discussed next.



\subsection{Realising WSML Semantics through Meta Axioms}
-- describe how a fixed set of rules implements (part of) the WSML semantics during reasoning \\
-- -- each WSMl entity is mapped to a datalog constant \\
-- -- special meta-level predicates stand for specific WSMl constructs with a certain semantics; they are applied to datalog constants (give example in picture) \\
-- -- a direct mapping would not facilitate metamodelling as a feature of WSML \\
-- -- meta-level axioms assure that the proper semantics of the wSMl constructs is maintained \\
-- -- the meta-level axioms form rules for the meta-level predicates (, which appear in these rules) \\
-- -- explain the intuition behind the various meta-level axioms \\

The mapping from WSML to datalog in the reasoning framework works
such that each WSML-identifiable entity, i.e.\ concept, instance,
attribute etc., is mapped to an instance (or logical constant) in
datalog, as depicted in Figure \ref{fig:meta}. There, the concepts
$C_1, C_2, C_3$ as well as the instances $I_1, I_2$ and the
attribute $a$ are mapped to constants such as $I_{C_1}$, $I_{I_1}$
or $I_a$ in datalog, representing the original WSML entities on
the instance level.

Accordingly, the various special-purpose relations that hold
between WSML entities, such as \wsml{subConceptOf},
\wsml{memberOf} or \wsml{hasValue}, are mapped to datalog
predicates that form a meta-level vocabulary for the WSML language
constructs. These are the meta-level predicates that appear in
Table \ref{tab:LE2datalog}, and which are applied to the datalog
constants that represent the WSML entities. The facts listed in
Figure \ref{fig:meta} illustrate the use of the meta-level
predicates. For example, the predicate \psco takes two datalog
constants as arguments that represent WSML concepts, to state that
the concept represented by the first argument is a subconcept of
the one represented by the second argument; on the other hand, the
predicate \pmo takes a datalog constant that represents a WSML
instance and one that represents a WSML concept, to state that the
instance is in the extension of this concept.

In contrast to a direct mapping from WSML to datalog with
concepts, attributes and instances mapping to unary predicates,
binary predicates and constants, respectively, this indirect
mapping allows for the WSML metamodelling facilities.
Metamodelling allows an entity to be a concept and an instance at
the same time. By representing a WSML entity as a datalog
constant, it could, for example, fill both the first as well as
the second argument of e.g.\ the predicate \pmo, in which case it
is interpreted as both an instance and a concept.\sgr{does this
become clear or is there more that needs to be said?}

\begin{figure}[tb]
        \includegraphics[width=8cm]{figures/meta}
        \centering
    \caption{Meta-level predicates and axioms for realising the WSML semantics. \label{fig:meta}}
\end{figure}

% -- old table for meta-level predicates + meta-level axioms
%\def\filler{\phantom{l}}
%\begin{table}[tb]\label{tab:meta-level}\centering
%\begin{tabular}{|l|l|}
%  \hline
%  \multicolumn{2}{|l|}{\emph{Meta-Level Predicates}} \\
%  \filler \begin{small}Predicate\end{small} & \begin{small}WSML construct\end{small} \\
%  \hline
%  \filler $\psco(C_{sub},C_{sup})$ \qquad\qquad & $C_{sub}$ \wsml{subConceptOf} $C_{sup}$ \\
%  \filler $\pmo(I,C)$ & $I$ \wsml{memberOf} $C$ \\
%  \filler $\phval(I,a,V)$ & $I[a$ \wsml{hasValue} $V]$ \\
%  \filler $\pitype(C,a,T)$ & $C[a$ \wsml{impliesType} $T]$ \\
%  \filler $\potype(C,a,T)$ & $C[a$ \wsml{ofType} $T]$ \\
%  \hline\hline
%  \multicolumn{2}{|l|}{\emph{Meta-Level Axioms}} \\
%  \hline
%  \multicolumn{2}{|l|}{\filler $\psco(C_1,C_3) \leftarrow \psco(C_1,C_2) \wedge \psco(C_2,C_3)$} \\
%  \multicolumn{2}{|l|}{\filler $\pmo(I,C_2) \leftarrow \pmo(I,C_1) \wedge \psco(C_1,C_2)$} \\
%%  \multicolumn{2}{|l|}{\filler $\pmo(V,C_2) \leftarrow \pitype(C_1,a,C_2) \wedge \pmo(I,C_1) \wedge \phval(I,a,V)$} \\
%  \multicolumn{2}{|l|}{\filler $\pmo(V,C_2) \leftarrow \pitype(C_1,a,C_2) \wedge \pmo(I,C_1)$} \\
%  \multicolumn{2}{|l|}{\filler \phantom{$\pmo(V,C_2) \leftarrow$} \qquad $\wedge \phval(I,a,V)$} \\
%%  \multicolumn{2}{|l|}{\filler $ \leftarrow \potype(C_1,a,C_2) \wedge \pmo(I,C_1) \wedge \phval(I,a,V) \wedge \neg \pmo(V,C_2)$} \\
%  \multicolumn{2}{|l|}{\filler $ \leftarrow \potype(C_1,a,C_2) \wedge \pmo(I,C_1)$} \\
%  \multicolumn{2}{|l|}{\filler $ \phantom{\leftarrow} \qquad \wedge \phval(I,a,V) \wedge \neg \pmo(V,C_2)$} \\
% \hline
%\end{tabular}
%\caption{Meta-level axioms and predicates for WSML semantics in
%datalog.}
%\end{table}
\begin{table}[tb]\label{tab:meta-level}\centering
\begin{small}
\begin{tabular}{|ll|}
  \hline
  \multicolumn{2}{|l|}{\rule{0cm}{3.2mm}{\normalsize \emph{Meta-Level Axioms}}} \\
  \hline
  (1) & $\psco(C_1,C_3) \dlogrule \psco(C_1,C_2) \dlogand \psco(C_2,C_3)$ \\
  (2) & $\pmo(I,C_2) \dlogrule \pmo(I,C_1) \dlogand \psco(C_1,C_2)$ \\
  (3) & $\pmo(V,C_2) \dlogrule \pitype(C_1,a,C_2) \dlogand \pmo(I,C_1)$ \\
  & \phantom{$\pmo(V,C_2) \dlogrule$} $\dlogand \phval(I,a,V)$ \\
  (4) & $\dlogcstr \potype(C_1,a,C_2) \dlogand \pmo(I,C_1)$ \\
  & \phantom{$\dlogcstr$} $\dlogand \phval(I,a,V) \dlogand \dlognot \pmo(V,C_2)$ \\
 \hline
\end{tabular}
\end{small} \caption{Meta-level axioms for WSML semantics in
datalog.}
\end{table}

A fixed set \mlaxioms of datalog rules forms the meta-level axioms
which assure that the proper semantics of the WSML language is
maintained. In these axioms, the meta-level predicates are
interrelated according to the semantics of the different language
constructs. Table \ref{tab:meta-level} shows the rules that make
up the meta-level axioms in \mlaxioms. Axiom (1) realizes
transitivity for the WSML \wsml{subConceptOf} construct, while
axiom (2) ensures that an instance of a subconcept is also an
instance of its superconcepts. Axiom (3) realizes the semantics
for the \wsml{implisType} construct for attribute ranges: any
attribute value is concluded to be in the extension of the range
type declared for the attribute. Finally, axiom (4) realizes the
semantics of the \wsml{ofType} construct by a constraint that is
violated whenever an attribute value cannot be concluded to be in
the extension of the declared range type.

\subsection{Mapping WSML Reasoning Tasks to Datalog Querying}
-- describe how to realise WSML satisfiability and entailment through datalog querying \\
-- -- characterize the KB (datalog program) on which reasoning is performed with the different facts and rules  \\
-- -- show how the WSML reasoning tasks are mapped to datalog queries (KB sat., entailment and conjunctive query answering) \\

To perform reasoning over the original WSML ontology $O$ with an
underlying datalog inference engine, a datalog program
\begin{displaymath}
    P_O = \mlaxioms \cup \tau(O)
\end{displaymath}
is build up, consisting of the meta-level axioms togeter with the
transformed ontology. The different WSML reasoning tasks are then
realized by performing datalog queries on $P_O$, as follows.
\begin{small}
\begin{tabular}{|l|l|}
  \hline
  $O$ is satisfiable & $(P_O, \qury \dlognot \square) \rightarrow \top$ \\
  $O \models \phi(\vec{C})$ & $(P_O, \qury \phi(\vec{C})) \rightarrow \top$ \\
  $\{\vec{X} : O \models Q(\vec{X})\}$ & $\{\vec{X} : (P_O, \qury Q(\vec{X})) \rightarrow \top\}$ \\
 \hline
\end{tabular}
\end{small}

( $\phi_g$ : ground fact ; $\vec{X}$ : variable binding )


\subsection{Realising Datatype Reasoning}
-- describe how reasoning with datatypes is realised As a result
of the transformations described previously, a generic Datalog
program is created. This generic program cannot be executed,
however, on a particular Datalog implementation without any
changes. Although most of the Datalog rules are understood by any
Datalog implementations, realizing datatype reasoning has some
intricate challenges.

To demonstrate the problems with datatype reasoning, consider the
ontology snippet shown in Figure~\ref{fig:datatype_example}.

\begin{figure}[hbt]
\centering
\begin{lstlisting}[style=wsml, frame=none]
concept Humanoid
  heightInFeet ofType _decimal

//Humanoids that are bigger than 7 feet are big
axiom bigHumanoidDefinition definedBy BigHumanoid(?x) :- ?x
memberOf Humanoid and ?x[heightInFeet hasValue ?v] and ?v > 7.0.

instance arwen memberOf Humanoid
  heightInFeet hasValue 5.5

instance aragorn memberOf Humanoid
  heightInFeet hasValue "big"
\end{lstlisting}
 \caption{Datatype example. \label{fig:datatype_example}}
\end{figure}

It is easy to see that the definition of \syn{aragorn} is not
correct, because the constant "big" is not a decimal number. I.e.,
the ontology is not satisfiable. On the other hand, the definition
of \syn{arwen} is correct, because $5.5$ is a decimal number.

The constraint that should check the datatype constraint on
\syn{heightInFeet} is the following, according Axiom (4) in
Table~\ref{tab:meta-level}:
\begin{displaymath}
    \leftarrow \potype(Humanoid,heightInFeet,_decimal) \wedge \\
    \phantom{\leftarrow} \pmo(I,Humanoid) \\
  \phantom{\leftarrow} \wedge \phval(I,heightInFeet,V) \\
  \phantom{\leftarrow} \wedge \neg \pmo(V,_decimal)
\end{displaymath}

The problem is that during the transformation steps no $\neg
\pmo(V,_decimal)$ statement is generated, because datatype
constants such as $5.5$ or "big" are built-in constructs, and no
explicit axioms state their type. As a result, the constraint will
be always violated whenever the \syn{heightInFeet} attribute has a
value; independently from the fact whether the value is correct
(as in the case of \syn{arwen}) or incorrect (as in the case of
\syn{aragorn}).

To solve this problem, \pmo facts for all datatype constants that
appear in the ontology should be generated. I.e., for each
constant in the ontology axioms of the following form should
appear:
\begin{displaymath}
    \pmo(V,D) \wsml{\lprl} \typeof(V, D_T)
\end{displaymath} where $D$ denotes the WSML datatype, $D_T$ denotes a datatype supported by the underlying Datalog implementation, which is compatible with the WSML datatype, and \typeof denotes a built-in predicate implemented by the Datalog tool, which checks whether a constant value belongs to the specified datatype.

Including such axioms into the tool-specific Datalog program
yields the correct result that the definition of \syn{aragorn}
violates the \synkw{ofType} constraint, while the definition of
\syn{arwen} does not.

WSML also supports some built-in predicates on datatypes, such as
numeric comparison\footnote{A full list of WSML datatypes can be
found in the WSML specification \cite{wsml-spec}.}. E.g., the
definition of \syn{BigHumanoid} uses a shortcut of the WSML
\synkw{numericGreaterThan} predicate. Clearly, these special WSML
predicates have to be translated to the corresponding built-in
predicates supported by the built-in Datalog reasoner.

To summarize the discussion, the underlying Datalog implementation
must fulfill the following requirements to support WSML datatype
reasoning:
\begin{itemize}
    \item It should provide built-in datatypes that correspond to WSML built-in datatypes.
    \item It should provide a predicate (or predicates) for checking the datatype of a constant.
    \item It should provide built-in predicates that correspond to WSML built-in predicates.
\end{itemize}

The main Datalog engine we used during our work was the KAON2
inference engine\footnote{KAON2 is available for download from
\url{http://kaon2.semanticweb.org}} \cite{hustadt04reducing}.
KAON2 provides a very flexible type system that allows for
user-defined datatypes, together with user-defined predicates on
these datatypes, including type checking predicates. Therefore,
KAON2 meets the identified requirements easily. As a matter of
fact, KAON2 already provided most of the required datatypes and
predicates out of the box. Of course, any other Datalog
implementation, can be used that fulfills the requirements (such
as MINS (TODO: insert reference here)).
