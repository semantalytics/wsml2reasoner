\subsection{Transforming WSML to Datalog}
-- describe different transformation steps \\

The transformation of a WSML ontology to datalog rules forms a
pipeline of single transformation steps which are subsequently
applied, starting from the original ontology.

\paragraph{Axiomatization} -- In a first step, the transformation
\transax is applied as a mapping $\O \mapsto \powset{\LE}$ from
the set of all valid rule-based WSML ontologies to the powerset of
all logical expressions that conform to rule-based WSML. \transax
converts all conceptual syntax elements, such as concept and
attribute definitions or cardinality and type constraints, into
appropriate logical expressions according to
\cite{wsml-spec}(Table 8.1). \sgr{give the complete conversion
table instead of the following example ??}

To give an example, the WSML fragment
\begin{lstlisting}[style=wsml]
concept C subConceptOf D
    r ofType (0 2) T
instance a memberOf C
    r hasValue b,c
\end{lstlisting}
is translated by \transax to the following logical expressions.
\begin{lstlisting}[style=wsml]
C subConceptOf D. C[r ofType T]. !- ?x memberOf C and ?x[r
hasValue?y1, r hasValue ?y2] and ?y1 != ?y2. a memberOf C.  a
hasValue b,c.
\end{lstlisting}

\paragraph{Normalization} -- The transformation \transnorm is
applied to normalize WSML logical expressions as a mapping
$\powset{\LE} \mapsto \powset{\LE}$. This normalization step
reduces the complexity of WSML logical expressions according to
\cite{wsml-spec}(Section 8.2) to make them better fit the simple
syntactic form of literals in datalog rules. This reduction
includes conversion to negation and disjunctive normal forms as
well as decomposition of complex WSML molecules. The various
normalization steps are shown in Table \ref{tab:normalization}.
\sgr{include this table or rather skip it??} After \transnorm has
been applied, the resulting WSML logical expressions have the form
of logic programming rules with no deep nesting of logical
connectives.

\begin{table}[tb]\label{tab:normalization}\centering
\begin{footnotesize}
\begin{tabular}{|l|l|}
  \hline
  \rule{0cm}{3.2mm}{\normalsize \emph{original expression}} & {\normalsize \emph{normalized expression}} \\
  \hline
    $\transnorm(\{E_1 , \dots , E_n\})$ & $\{\transnorm(E_1) , \dots , \transnorm(E_n)\}$ \\
    $\transnorm(X$ \wsml{and} $Y.)$ & $\transnorm(X)$ \wsml{and} $\transnorm(Y)$ \\
    $\transnorm(X$ \wsml{or} $Y.)$ & $\transnorm(X)$ \wsml{or} $\transnorm(Y)$ \\
    $\transnorm(X$ \wsml{and} $(Y$ \wsml{or} $Z).)$ & $\transnorm(\transnorm(X)$ \wsml{and} $\transnorm(Y)$ \wsml{or} \\
    & $\phantom{\transnorm(}\transnorm(X)$ \wsml{and} $\transnorm(Z).)$ \\
    $\transnorm((X$ \wsml{or} $Y)$ \wsml{and} $Z).)$ & $\transnorm(\transnorm(X)$ \wsml{and} $\transnorm(Z)$ \wsml{or} \\
    & $\phantom{\transnorm(}\transnorm(Y)$ \wsml{and} $\transnorm(Z).)$ \\
    $\transnorm($ \wsml{naf} $ (X$ \wsml{and} $Y).)$ & $$ \wsml{naf} $ \transnorm(X)$ \wsml{or} $$ \wsml{naf} $ \transnorm(Y).$ \\
    $\transnorm($ \wsml{naf} $ (X$ \wsml{or} $Y).)$ & $$ \wsml{naf} $ \transnorm(X)$ \wsml{and} $$ \wsml{naf} $ \transnorm(Y).$ \\
    $\transnorm($ \wsml{naf} $ ($ \wsml{naf} $ X).)$ & $\transnorm(X)$ \\
    $\transnorm(X$ \wsml{implies} $Y.)$ & $\transnorm(Y)$\wsml{\lprl}$\transnorm(X).$ \\
    $\transnorm(X$ \wsml{impliedBy} $Y.)$ & $\transnorm(X)$\wsml{\lprl}$\transnorm(Y).$ \\
    $\transnorm(X[Y_1 , \dots , Y_n].)$ & $X[Y_1]$ \wsml{and} $\dots$ \wsml{and} $X[Y_n].$ \\
  \hline
\end{tabular}
\end{footnotesize}
\caption{Normalization of WSML logical expressions.}
\end{table}

\paragraph{Lloyd-Topor Transformation} -- The transformation
\translt is applied as a mapping $\powset{\LE} \mapsto
\powset{\LE}$ to flatten the complex WSML logical expressions,
producing simple rules according to the Lloyd-Topor
transformations \cite{lloyd-topor}, as shown in Table
\ref{tab:lloyd-topor}. \sgr{is the specification of the
lloyd-topor transformations correct? (esp. the middle one with
nested LP-rule and the lack of parenthesis)}
\begin{table}[tb]\label{tab:lloyd-topor}\centering
\begin{footnotesize}
\begin{tabular}{|l|l|}
  \hline
  \rule{0cm}{3.2mm}{\normalsize \emph{original expression}} & {\normalsize \emph{simplified rule(s)}} \\
  \hline
  $\translt(H_1$ \wsml{and} $\dots$ \wsml{and} $H_n$\wsml{\lprl}$B.)$ & $\translt(H_1$\wsml{\lprl}$B.)$ , \dots , $\translt(H_n$\wsml{\lprl}$B.)$ \\
  $\translt(H_1$\wsml{\lprl}$H_2$\wsml{\lprl}$B.)$ & $\translt(H_1$\wsml{\lprl}$H_2$ \wsml{and} $B.)$ \\
  $\translt(H$\wsml{\lprl} $B_1$ \wsml{or} , $\dots$ , \wsml{or} $B_n.)$ & $\translt(H$\wsml{\lprl}$B_1.)$ , \dots , $\translt(H$\wsml{\lprl}$B_n.)$ \\
  \hline
\end{tabular}
% --old tabel with Lloyd-Topor trasnformations
%\begin{tabular}{|c|c|}
%  \hline
%  % after \\: \hline or \cline{col1-col2} \cline{col3-col4} ...
%  \emph{original expression} & \emph{simplified rule(s)} \\
%  \hline
%  $H_1 \wedge \dots \wedge H_n \leftarrow B$ & $H_1 \leftarrow B , \dots , H_n \leftarrow B$ \\
%  $H_1 \leftarrow H_2 \leftarrow B$ & $H_1 \leftarrow H_2 \wedge B$ \\
%  $H \leftarrow B_1 \vee \dots \vee B_n$ & $H \leftarrow B_1 , \dots , H \leftarrow B_n$ \\
%  \hline
%\end{tabular}
\end{footnotesize}
\caption{Lloyd-Topor transformations.}
\end{table}
After this step, the resulting WSML expressions have the form of
proper datalog rules with a single head and conjunctive (possibly
negated) body literals.

\paragraph{Datalog Rule Generation} -- In a final step, the
transformation \transdlog is applied as a mapping $\powset{\LE}
\mapsto \P$ from all valid logical expressions in rule-based WSML
to the set of all datalog programs, yielding generic datalog rules
that represent the content of the original WSML ontology. In this
generic datalog program, all remaining WSML-specific language
constructs, such as \wsml{subConceptOf} or \wsml{ofType}, are
replaced by special meta-level predicates for which the semantics
of the respective language construct is encoded in meta-level
axioms as described in a further subsection.
\begin{table}[tb]\label{tab:LE2datalog}\centering
\begin{footnotesize}
\begin{tabular}{|l|l|}
  \hline
  \rule{0cm}{3.2mm} {\normalsize \emph{WSML}} & {\normalsize \emph{Datalog}} \\
  \hline
  $\transdlog(\{E_1, \dots , E_n\})$ & $\{\transdlog(E_1), \dots , \transdlog(E_n)\}$ \\
  $\transdlog($ \wsml{\cstr} $B.)$ & $\dlogcstr \transdlog(B)$ \\
  $\transdlog(H)$ & \dlogfact{\transdlog(H)} \\
  $\transdlog(H$ \wsml{\lprl} $B.)$ & $\transdlog(H) \dlogrule \transdlog(B)$ \\
  $\transdlog(X$ \wsml{and} $Y.)$ & $\transdlog(X) \dlogand \transdlog(Y)$ \\
  $\transdlog(C$ \wsml{subConceptOf} $D.)$ & $\psco(C,D)$ \\
  $\transdlog(I$ \wsml{memberOf} $C.)$ & $\pmo(I,C)$ \\
  $\transdlog(I[a$ \wsml{hasValue} $V].)$ & $\phval(I,a,V)$ \\
  $\transdlog(C[a$ \wsml{impliesType} $T].)$ & $\pitype(C,a,T)$ \\
  $\transdlog(C[a$ \wsml{ofType} $T].)$ & $\potype(C,a,T)$ \\
  $\transdlog($\wsml{r}$(X_1, \dots , X_n).)$ & $r(X_1, \dots , X_n)$ \\
  $\transdlog(X$ \wsml{=} $Y.)$ & $X = Y$ \\
  $\transdlog(X$ \wsml{!=} $Y.)$ & $X \neq Y$ \\
  \hline
\end{tabular}
\end{footnotesize}
\caption{Transformation from logical expressions in rule-based
WSML to datalog including meta-level predicates.}
\end{table}
Table \ref{tab:LE2datalog} shows the mapping from WSML logical
expressions to datalog including the meta-level predicates \psco,
\pmo, \phval, \pitype and \potype that represent their respective
WSML language constructs as can be seen from the mapping.

\bigskip

Ultimately, the basic\footnote{In Section \ref{sec:debugging} the
transformation pipeline is modified to support debugging
features.} transformation pipeline for converting a rule-based
WSML ontology into a datalog program is the following, constituted
by the single transformation steps introduced before.
\begin{displaymath}
    \tau = \transdlog \circ \translt \circ \transnorm \circ \transax
\end{displaymath}
As a mapping $\O \mapsto \P$, this chaining of the single steps is
applied to a WSML ontology $O \in \O$ to yield a semantically
equivalent datalog program $\tau (O) = P \in \P$ when interpreted
with respect to the meta-level axioms discussed next.
